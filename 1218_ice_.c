/*冬の寒いある日，JOI太郎君は広場に張った薄氷の上を渡り歩いて遊ぶことにした。 広場は長方形で， 東西方向に m 個， 南北方向に n 個， つまり，  m × n の区画に区切られていて， 薄氷が有る区画もあれば薄氷が無い区画もある。JOI太郎君は，次のルールに従って，区画を渡り歩きながら薄氷を割っていくことにした。
渡り歩きは，薄氷があるどの区画からでも始めることができる。これを第１歩目とする。
第i 目の区画からは，その区画の東西南北のいずれかの方向に隣接し薄氷の有る区画に渡ることができる。これが第 i+1 目となる。
第 i+1 歩目の区画に渡ったら第 i 歩目の区画の薄氷を割る。
JOI太郎君が渡り歩ける最大歩数を求めるプログラムを作成せよ。 ただし， 1 ≦ m ≦ 90，1 ≦ n ≦ 90 である。 与えられる入力データでは， 可能な渡り歩きの方法は20万通りを超えない。
入力
入力は n + 2 行ある。 1 行目には整数 m が書かれている。 2 行目には整数 n が書かれている。3 行目から n + 2 行目までの各行には、0 もしくは 1 が， 空白で区切られて m 個書かれており， 各区画に薄氷が有るか否かを表している。 北から i 番目，西から j 番目の区画を (i, j) と記述することにする  (1 ≦ i ≦ n, 1 ≦ j ≦ m) と，  第 i + 2 行目の j 番目の値は，  区画 (i, j) に薄氷が有ると 1 となり，  区画 (i, j) に薄氷が無いと 0 となる。
出力
渡り歩ける最大歩数を１行として書き出せ。
*/
#include<stdio.h>

#define MAX 90

int n,m;
int max = 0; //現在における最大の歩数
int map[MAX][MAX] = {0}; //氷の状態

void getWay(int x, int y, int cost){

	int i,nx = 0,ny = 0;
	int dx[] = {1,0,-1,0};
	int dy[] = {0,1,0,-1};
	//今歩いてる歩数がすでにmaxより大きいなら上書きする
	if(max < cost){
		max = cost;
		//そこは割れているため0
		map[x][y]=0;
	}
	//4方向に対してみる
	for( i = 0; i<4; i++){
		//動いてみて
		nx = x + dx[i];
		ny = y + dy[i];
		//そこがmapの範囲で
		if(nx >=0 && ny >=0 && nx < m && ny < n){
			//かつ道があるのなら
			if(map[nx][ny] == 1){
				//今ある場所から歩数を＋１して再起
				getWay(nx,ny,cost+1);
			}
		}
	}
	map[x][y]=1;
	
	
}

int main(void){
	
	int i,j;
	scanf("%d",&m);
	scanf("%d",&n);
	if(m == 0 && n == 0){
      return 0;
    }
	//読み込み
	 for (i = 0; i < m; i++){
            for (j = 0; j < n; j++){
                scanf("%d", &map[i][j]);
            }
        }
	for (i = 0; i < m; i++){
            for (j = 0; j < n; j++){
                if (map[i][j] == 1){
                    getWay(i, j, 1);
                }
            }
        }
	
	return 0;
}
